# 1.数组：

0. 数组存储了几种信息？

   2种，一是下标，二是值。

   经典算法：素数筛

1. 数组是展开的函数，函数是压缩的数组。（经典例题：秦腾的教学评估）

2. 计算机中最重要的两类资源：计算资源（函数）、存储资源（数组）。　他俩可以互相转化。

3. 数组和函数的本质是相同的——映射。

   数组是整形到数组类型的一一映射

   函数是任意类型到任意类型的一一映射

4. 函数的形参中如果有函数，则可以换成数组。



## 数组与地址：

0. 以下两种写法等价(int arr[100])

   arr + i

   &(arr[i])

1. 一维数组在做函数参数时，形参可用int *a， 实参传入a就行，如下

   

   ```c
   int func(int *a) {
       return a[1];
   }
   
   int main() {
       int a[10];
       printf("a[1] = %d\n", a[1]);
     	printf("func(a) = %d\n", func(a));
   }
   
   //实际上两者有着本质上的区别，用sizeof输出一下func函数中的a和主函数中的a就知道区别了
   //func函数中的a本质上是个指针型变量，sizeof(a)是8个字节
   //主函数中的a本质上是个数组的首地址，sizeof(a)是40字节
   ```

2. 二维及以上数组在做函数参数时，不可以用int **a，因为这时候行为模式就不同了，即向后移动一个元素的位置的地址就不同了，即a + 1会移动8个字节而在主函数中的a + 1会移动一行的int数的字节。如下

   ``` c
   int func(int (*a)[100]) {
       return a[1][3];
   }
   
   int main() {
       int a[10][100];
       a[1][3] = 641;
       printf("a[1][3] = %d\n", func(a));
   }
   //要想成功传参，必须保证主函数中实参a + 1移动的字节数==传入的函数中的形参a+1移动的字节数
   //即只有第一维的参数可以省略
   ```

   

# 2.预处理命令：



1. 学会预处理命令，就可以从木匠变为==魔法师==

2. 预处理命令分为宏定义和条件式编译

3. 预处理命令作用在**<u>*预处理阶段*</u>**

   ![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gmbil4dlpgj30my0a7q5h.jpg)

   



## 2.1宏定义

1. 宏定义一般有三种应用：

   + 一是定义符号常量

     `#define  PI 3.1415926`

   + 二是定义傻瓜表达式

     `#define MAX(a, b) (a) > (b) ? (a) : (b)`

     `#define S(a, b) a * b`

   + 三是定义代码段

     ```C
     #define P(a) {\
     	printf("%d\n", a);\
     }
     ```

+ ==只占一行==
+ 本质：==只是简单的替换！！！==

3. 预定义的宏

   ![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gmbib5a2x0j30ru0f5q9k.jpg)

   如果换了环境不好使，那就是非标准的。

4. g++ -E可以查看预处理之后的待编译源码。

5. 随堂练习2：

   ![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gmbioamj5kj30ov0es79t.jpg)

   答案：

   ```c
   #include <stdio.h>
   
   //多行代码段的返回值要等于最后一行的返回值，所以必须要套上一层()
   #define MAX(a, b) ({\
       __typeof(a) _a = (a);\
       __typeof(b) _b = (b);\
       _a > _b ? _a : _b;\
   })
   #define P(a) {\
       printf("%s = %d\n", #a, a);\
   }
   
   int main() {
       int a = 7;
       P(MAX(2, 3));
       P(5 + MAX(2, 3));
       P(MAX(2, MAX(3, 4)));
       P(MAX(2, 3 > 4 ? 3 : 4));
       P(MAX(a++, 6));
       P(a);
       return 0;
   }
   ```

   __typeof__(A) 意思是取的A的类型。以MIN(++a, ++b)来说，因为我们要重新定义变量来接收a的值， 防止++a多次运行，那么定义变量之前我们要先知道这个a的类型，他可能是int 也可能是 float， 我们不会提前知道，所以用__typeof__(A)来取得他的类型，__typeof__()可以理解为取括号里面的变量的类型

   那么就可以知道第一句 大致意思为  int __a = ++a; 同理 int __b = ++b; 最后比较新定义的变量__a > __b ? __b : __a; 

6. 变参宏：

   + 和变参函数类似，变参列表也是用...来表示
   + 只不过你要给变参列表起个名字。
   + 经典例题：log宏

7. 随堂练习3：

   ![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gmdteqcsk8j30no0dyjw2.jpg)

   答案：

   ```c
   #define LOG(frm, args...) {\
       printf("[%s : %d] ", __func__, __LINE__);\
       printf(frm, ##args);\  //这样看做连接内容就允许args为空，如果不加##则把args当成了宏中的参数，就不允许为空了，
   }
   
   int main() {
       int a = 7;
       LOG("%d\n", a);
       LOG("hello world!\n");
       return 0;
   }
   ```

   

8. #代表将后面的东西==字符串化==，即用双引号包围。

9. ##则用来==连接==两个前后参数。（直接用有bug,必须包一个)

   这样就允许前后某个参数为空！！！！！

   \##被称为连接符（concatenator），用来将两个Token连接为一个Token，##符是把传递过来的参数当成字符串进行替代。

   ```c++
   //宏中的连接行为
   //演示4, 5中#　和 ##的作用
   #define contact(a, b) a##b
   #define P(a) {\
   	printf("%s = %d\n", #a, a);\
   }
   int main() {
   		int abcdef = 5;
   		contact(abc, def) = 21;
   		P(abcdef)
           return 0;
   }
   //第三行输出结果是21
   ```

   ```c++
   //解决bug的方法就是里面再套一层contact宏
   
   #define __contact(a, b) a##b
   #define contact(a, b) __contact(a, b)
   
   //光哥经典语录：没有什么是再套一层解决不了的，如果有，那就再套一层！！！
   ```

   第一步：首先用实参代替形参，将实参代入宏文本中

   第二步：如果实参也是宏，则展开实参

   第三步：最后继续处理宏替换后的宏文本，如果仍包含宏，则继续展开

   注意：如果在第二步，实参代入宏文本后，实参之前或之后遇到#或##，实参不再展开\

   #define cat(a,b) a ## b

   宏调用：cat(cat(1, 2), 3) 的展开顺序为：

   cat(cat(1, 2), 3) -->cat(1, 2) ## 3 -->cat(1, 2)3

   cat(1,2)仍是宏，但后面是##，不再展开，结果为：cat(1, 2)3

10. 宏展开遇到＃或者##就停止深一层递归展开！！！！！！

11. 随堂练习4：设计一个offset(T, name)宏，返回==在struct T中name字段的偏移量==

    ```c
    //写法1  笨方法
    #define offset(T, name) ({\
    	T tmp;\
    	(char *)&tmp.name - (char *)&tmp;\
    })
    
    //进阶写法
    //其实根本不需要声明变量
    #define offset(T, name) (long long)(&(((T *)(0))->name))
    ```

    

    



## 2.2条件式编译

| 函数             | 说明                 |
| ---------------- | -------------------- |
| #ifdef DEBUG     | 是否定义了DEBUG宏    |
| #ifndef DEBUG    | 是否没定义DEBUG宏    |
| #if MAX_N == 5   | 宏MAX_N是否等于5     |
| #elif MAX_N == 4 | 否则宏MAX_N是否等于4 |
| #else            |                      |
| #endif           |                      |

1. 功能就是可以实现到底要保留哪一段代码(如果if成立，就保留)

   所以我们可以利用条件式编译来对代码进行==选择与剪裁==

2. 用处：是保证C语言==可移植性==的重要工具

3. 这套工具，和环境强相关！！！！

4. 例子：

   2.2.log.cpp

## 其他：

1. 单纯的{}里面是代码块，这块代码没有返回值，只有在外层套一层()才变成==表达式==,而表达式的值就是复合语句的最后一个语句的值，类型是最后一个语句的类型。
2. ()内部不允许有多条语句？？？？？