# 为什么学习C语言：

## C语言和哪些东西息息相关？

1. 操作系统上编程：比方说自己实现个内存管理、写个服务器之类的事情
2. 设计操作系统
3. 网络协议的实现
4. 物联网
5. 写编译器



# C历史：

1. 在很久以前，在知名的贝尔实验室，有一个叫Ken Thompson和另一个叫Dennis M.Ritchie的工程师，他们为了在实验室角落里一台PDP-7的小型机上写一个让自己可以不用花多少钱就可以玩的《星际旅行(Star Travel)》的游戏，用汇编语言写了一个操作系统，并把这个系统命名成了Unix。

   然而，一个汇编写的操作系统，是没有办法在不同的计算机上普适使用的。所以呢，Ken和Dennis为了让更多人在非PDP-7小型机的计算机上也玩上《星际旅行》的游戏，决定用高级语言改写unix。

   在纠结使用什么高级语言来改写他们视如儿子的unix系统时，他们“可怕的创造力”再一次发挥了作用。他们在Ken早年设计的B语言的基础上设计出了我们现在这门课关注的“大Boss”--C Programming Language。



# 编译与运行

1. 你编写的C语言程序通常以.c结尾，例如main.c，可以通过执行gcc -o program main.c进行编译(compile)，告诉一个叫gcc的编译器，我们要编译生成一个名叫program的可执行文件(用 -o program进行说明)，被编译的代码文件是main.c。

   如果编译成功，我们在同一个目录下可以得到一个编译后的可以执行的program程序。再通过执行./program的方式你就可以执行这个程序了。



# 宏定义：

1. 宏定义会在编译前被预处理，所以它的替换过程并不会占用程序运行时的时间。所以对于一些可被配置，在程序中不会被修改的量（如数组长度）和结构，我们都极为推荐使用宏定义的方式来进行设计。

# 字符串：

1. 广义所讲字符串实际上是被更为严谨地称为：==字符串字面量(string literal)==。它在我们写的程序中表现为一对双引号包裹的０个或多个字符。
2. “字面量池区”与“栈区”、“堆区”、“全局区”都没有包含关系。
3. 程序的字面量和变量==在程序运行时==都会被储存在==内存==中。

# 动态分配内存：

1. Ｃ语言程序==在编译时==会被分配到内存上的一片有限的连续区域，这部分内存会被用于存储==局部变量==(在某一个函数内声明的变量)的值。我们平时声明局部变量、给局部变量赋值的时候就在使用这部分的内存。这部分的内存区域被我们称为——栈区(==stack==)。

2. 相对应的还有一片区域叫做堆区(==heap==)，这部分的内存是我们通过程序手动地向系统申请的。<u>**栈区内存大小编译时就已经被限制**</u>，如果使用超出限制的内存就会出现"溢出"的情况，而堆区的内存可以一直被申请、使用，直到操作系用中的有效内存无法再被申请为止，相比之下，堆区控制起来更为灵活。

   + 正是因为栈区上内存大小受限制的缘故，在内存需要比较大的（超出栈区限制）情况下，我们会需要申请堆区上的内存。

   + 但是，堆区被申请后，在使用的过程中==若不释放就可能会出现“内存泄露（memory leak）”==。很多企业级的应用，都因为内存泄漏而在“正常”运转很长时间后，轰然“坍塌”。

   + 如果我们需要使用堆上内存，我们就会需要将malloc.h或stdlib.h引入到程序中来，这两个标准库，都定义了申请、管理堆区上内存的函数。

   + 在引入了必要的标准库后，我们可以通过

     ```c
     int *p;
     p = (int *) malloc(sizeof(int));
     ```

     的方式声明一个整数型的指针p，向系统申请堆区上sizeof(int)（表示一个整数型变量所需的内存空间大小）的一块内存空间，并将指针Ｐ赋值为这片空间所在的起始地址，使得Ｐ指向这片空间。

   + 如何想开多少长度的数组就开多少？

     ```c
     #include <stdio.h>
     #include <malloc.h>
     
     int main() {
     		int n;
       scanf("%d", &n);
       int *a = (int *) malloc(n * sizeof(int));
     			//相当于int a[n];
     		 //OR int * a = (int *) calloc(n, sizeof(int));
       //calloc函数申请的内存空间全部被初始化为了０；而malloc没有初始化
     			free(a);
       a = NULL;//上面两行释放堆区上申请的内存空间并将a指针指向空
       return 0;
     }
     ```

     

3. 除此之外，还有一块==全局区（或称为静态区，static storage area）==,程序中的全局变量和静态变量被存储在这块内存区域中。

   

# 结构体：

1. 结构体成员元素在结构体描述中的顺序==完全有可能==会影响到结构体使用时所需要的内存大小。
   + 结构体里面的元素都是顺序存储的，可以按元素的字节大小偏移来访问but要注意考虑字节对齐的问题，x86机器都是按4字节对齐的，如果你的结构体里面有不是4字节倍数的变量，那么偏移会出错，要在文件头上加一个param pack（1），意思是按一个字节对齐。

# 链表：

1. 对于确定长度的同类型数据，我么之前以及学习了如何使用数组进行储存。而对于==长度不确定的==、==经常需要改变==的数据，我们则会选择构造一个被称为**<u>链表（linked list）</u>**的结构。

2. 链表由一系列存储了数据的节点和它们之间的指向关系构成。从第一个节点（链表头）开始，每个节点都会指向下一个节点，直到链表末端的一个节点为止。
3. C语言实现方式：结构体
4. 在这个结构体中，有一系列的数据，同时还有一个指向这一结构体类型的指针。

5. 相对于数组来说，链表有一定的优势和劣势。

   | 优势                                                         | 劣势                                                         |
   | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | 存储的元素数目不固定，数据结构所需的内存空间无需一开始就说明。 | 在内存中不连续，查询效率没有数组高，需要从链表头开始沿着指针方向依次访问每一个节点才能到达目标节点。 |
   | 只要改变指针指向就可以==动态地==在两个节点之间插入数据       |                                                              |

   

6. 代码演示：

   ```c
   //首先定义一个结构体
   typedef struct node {
     int number;
     struct node *next;
   } Node;
   //接着定义一个用于生成链表节点的函数，其中，它会创建一个临时节点，在堆区内存上申请一块空间，并且在其中存储给定的整数，默认创建的节点内next指针都指向NULL，表示没有下一个节点。
   
   Node *create_node(int new_number) {
     Node *temp_node;
     temp_node = (Node *) malloc(sizof(Node));
     temp_node -> number = new_number;
     temp_node -> next = NULL;//表示没有下一个节点
     return temp_node;
   }
   
   int main() {
   //接下来我让我们在main函数中创建一个链表，让其包括三个节点。
     Node *head;//只要定义指向结构体的指针就够了！！！因为有了上面生成链表节点的函数！！
     head = create_node(1);
     head -> next = create_node(2);
     head -> next -> next = create_node(3);
     
     free(????)//从内存安全的角度出发，我们应该还要在链表被使用完毕后释放所有开辟给链表节点的堆区上的内存喔
     return 0;
   }
   
   ```

   

7. 如何创建一个循环链表？

   ```c
   typedef struct node {
       int data;
       struct node *next;
   } Node;
   
   Node *circle_create(int n) {
       Node *head, *temp, *new_node;
       int i;
       //创建第一个链表节点并加数据
       temp = (Node *) malloc(sizeof(Node));
       head = temp;
       head -> data = 1;
       //创建第二到第n个链表节点并加数据
       for (i = 2; i <= n; i++) {
           new_node = (Node *) malloc(sizeof(Node));
           new_node -> data = i;
           temp -> next = new_node;
           temp = new_node;
       }
       //最后一个节点指向头部构成循环链表
       temp -> next = head;
       return head;
   }
   ```

   

8. 经典题目：约瑟夫环问题

# 共用体：

1. 在C语言中，有一种看起来和结构体很像的东西，它被称为共用体（union）。结构体的特性解决了一系列不同类型的变量可以怎样被放在一起组织的问题，而共用体则使==多种不会同时出现的变量==共用同一块内存成为了可能，学会如何正确使用共用体将给我们带来很多的方便。

2. 定义共用体的关键字是==union==,一个共用体可以包括多个合法的类型描述成员，例如：

   ```
   union register {
   		struct {
   				unsigned char byte1;
   				unsigned char byte2;
   				unsigned char byte3;
   				unsigned char byte4;
   		} bytes;
   		unsigned int number;
   };
   ```

   这个共用体所占的内存空间是被==公用==的，可以通过这两种不同类型的成员进行访问。==无论我们通过哪一种描述成员访问这一共用体，我们访问的都会是同一块内存空间。==

3. 共用体其实也可以被视为一种特殊的结构体，但是一般的结构体中的成员==会在内存中对齐排列==，而共用体则都选择以同一位置作为起点，共用同一开始地址的内存。
4. 共用体类型的变量占用内存的大小将会和他所有成员中占用内存==最大的==一致。