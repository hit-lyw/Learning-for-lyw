# HaffmanTree

## 一、要解决的问题

最短平均编码长度

## 二、最优性体现在

1. 信息熵就是理论上的最短平均编码长度(min(WPL))，此时必须满足条件：==编码长度L(i) = log2(1/p(i))==，(PS:==求min的过程中有两步，一是确定了只有当所选结点覆盖所有叶子结点时才取min，第二步是由目标函数求偏导并令偏导=0所得结果，而这个公式是由第二步所求得的==)但是实际上很难出现这种情况，所以只能近似接近这种情况，即出现频次高的字符它的编码短(路径短)，频次低的字符它的编码长。（即下面的2）

2. 所选的结点覆盖了所有叶子结点，即出现频次高的字符它的编码短（路径短），频次低的字符它的编码长（路径长）。

### 三、Trademark

1. 给n个字符编码，这课haffmantree的深度就为n

## 四、建立

1. 所以haffmantree的建立就是每次取出现频次最低的两个结点生成新结点，直到结束，这样根结点的p字段就是总的频次。

2. 在haffmantree这个结构体定义中定义*codes字段(codes是Code类型的结构体)， 用来存放编码的字符及其编码，在完成1操作后进行提取编码操作。
3. 至此，完成haffmantree的建立。