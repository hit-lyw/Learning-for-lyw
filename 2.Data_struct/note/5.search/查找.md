

# 综述

1. 前言：查找数据是数据处理中使用最频繁的一项操作。

   ​			查找算法性能比较的一个重要指标就是平均查找长度(ASL)。

2. 查找是指在数据集合中寻找满足某种条件的数据元素的过程。

3. 用于查找的数据集合成为查找表(search table)。

4. 查找表中的数据元素类型是一致的，并且有能够唯一标识出元素的关键字(keyword)。

5. 通常对查找表有4中操作：

   + 查找：在查找表中查看某个特定的记录是否存在。
   + 检索：查找某个特定记录的各种属性。
   + 插入：将某个不存在的数据元素插入到查找表中。
   + 删除：从查找表中删除某个特定元素。

   如果对查找表只执行前两种操作，则称这类查找表为静态查找表(static search table)。静态查找表建立以后，就不能再执行插入或者删除操作，查找表也不再发生变化。

   如果对查找表还要执行后两种操作，则称这类查找表为动态查找表(dynamic search table)。

   本章我们要介绍的查找算法都是针对静态查找表的，比如顺序查找、折半查找、分块查找等。对于动态查找表，往往使用二叉平衡树、B-树或哈希表来处理。

6. 对于各种各样的查找算法，我们要如何比较他们的优劣呢？

   通常，我们使用平均查找长度(average search length,ASL)来衡量查找算法的性能。

   对于含有n个元素的查找表，定义查找成功的平均查找长度为

   ASL = PiCi(求和)

   其中Pi是搜索查找表中第i个记录的概率，并且Pi之和== 1，通常我们认为每个元素被查找的概率相等，即Pi = 1 / n。

   Ci是指搜索查找表中第i个元素时直到查找成功为止，表中元素的比较次数。

   考虑到查找不成功的情况，查找算法的平均查找长度应该是查找成功的ASL和查找不成功的ASL之和。但是通常我们在说ASL时，不考虑查找不成功的情况。

   

   



# 顺序查找

又称线性查找，sequential search。

1. 定义：

   是指在线性表中进行的查找算法。

   顺序查找算法是最直观的一种查找算法，它从线性表的一端出发，逐个比对关键字是否满足给定的条件。

2. 顺序查找按照查找表中数据的性质，分为对一般的无序线性表的顺序查找和对按关键字有序的线性表的顺序查找。



## 无序表的查找

1. 定义：

   基本思想是从线性表的一端开始，逐个比对关键字是否满足给定的条件。若找到某个元素的关键字满足给定的要求，则查找成功，若一直找到线性表的另一端仍未有满足要求的元素，则查找不成功。

2. ASL：

   ![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1gc3vuunyuyj31q20eggp9.jpg)





## 有序表的查找

1. 定义：

   对于有序表的顺序查找，在查找成功时与无序表的查找是一样的。而对于查找不成功的情况，无需和表中所有元素比对就可以确认查找不成功，这样能降低查找不成功时的ASL。

   具体来说，假设查找表a0,a1,a2,....an-1是从小到大排列的，查找的顺序是从左向右。若待检索的关键字为key，当查找到第i个元素时，如果第i个元素的值大于key，而之前并没有查找成功，就可以认为查找不成功了。

2. ASL：

   ![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gc3w0s733sj31r00bs0wg.jpg)

# Binary_search

本质：==缩小问题规模！==

## 普通情况

即1 3 4 6 7 8里寻找一个特定的数

1. 推导过程：

2. 图解：

   ![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gc393ymtczj31d60u01kx.jpg)

   PS:

   + 如果查找到，可能有==两种==情况

     + 一是head和tail没重合，arr[mid]是那个值
     + 二是最后head和tail重合了，arr[mid]是那个值

   + 如果未查找到，只有一种情况

     head和tail==重合后又错开==
     
   + 为什么while()里写==head <= tail==呢？

     因为就算head == tail了，也有可能不是要找的那个数！！！！(对比一下后两种二分！！)
     
   + 如果没找到的情况下想返回按顺序应插入的位置，就在代码第9行==return head==！！！(tail则不行)

     + 这句话并不完全正确，有种情况下是错的，就是查找比所有的数都小的数的时候

   代码如下

   ```C
   int binary_search1(int *arr, int n, int x) {//要在长度为n的数组中查找x，存在返回下标，不存在返回-1
     int head = 0, tail = n - 1, mid;
     while (head <= tail) {//为什么是<=呢？因为就算头尾指针重合，也有可能找到的不是那个数
       mid = (head + tail) >> 1;
       //也可写成mid = ((head ^ tail) >> 1) + (head & tail)
       //这样可以保证不超出int范围
       //因为两个数相加就等于两个数 相同部分+不同部分
       if (arr[mid] == x) return mid;
       if (arr[mid] < x) head = mid + 1;
       else tail = mid - 1;
     }
     return -1;//走到这一步说明没找到
   }
   ```

3. ASL：

   利用二叉判定树

   ![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gc3y3ugfuzj31d00u0woj.jpg)

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gc3y59d7n2j31qu0c443k.jpg)



## 特殊情况1

即1111110000找最后一个1这种情况(==找最后一个符合条件的值==！！)

0. 图解：

![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1gc3a5zqcjfj318j0u07ue.jpg)

1. 整体不变，只需要改动几个地方就行！

   + while ()里写head < tail！

     因为重合就说明一定可判断！要么就是找到了，要么就是全是0！

     PS:

     + 朴素的二分里如果重合也一定可判断，但它本身的while里的逻辑也可判断！！所以就不用跳出来判断了！

     + 那问题就来了，这种情况下，如果重合，本身while里的逻辑不能判断吗？

       确实不行！如果while()里依然写head <= tail的话，如果成功找到了那个位置，由于下一行的改动(head = mid)，会一直***<u>死循环</u>***！ 

   + if (arr[mid] == 1) head = mid;

     ==因为可能是最后一个1==

   + if (arr[mid] != 1) tail = mid - 1;

     这个不用变

   + 边界条件呢？

     + 全是1，最后肯定能找到最后一个1，不用特判

     + 全是0，最后肯定head和tail重合在1，还用特判

       这里采用一个技巧：虚拟头指针，即head一开始指向-1，如果最后没找到，肯定返回的是-1！！

   + 经过调试，还有最终的一个bug，就是mid要 = (head + tail + 1) >> 1

     因为由于/是向0取整的，会造成死循环，栗子：5，6位置上分别是1、0。(根本原因还是因为head = mid的那个改动！)

2. 代码如下

   ```C
   int binary_search2(int *arr, int n) {
     int head = -1, tail = n - 1, mid;
     while (head < tail) {
       mid = (head + tail + 1) >> 1;
       if (arr[mid] == 1) head = mid;
       else tail = mid - 1;
     }
     return head;//如果是000000，则返回-1， 妙啊！！
   }
   ```

   

## 特殊情况2

即000001111寻找第一个1

0. 图解：(这个图解有错误！！)

   ![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1gc3a98n6usj31be0u0u0c.jpg)

   1. 思路：和特殊情况1基本类似，只有以下改动

      + mid还是=(head + tail) >> 1;

        这里不存在死循环的问题，因为==要找的在后面==，不会造成head和tail永远不重合！

      + 虚拟头指针改成虚拟尾指针了！

   2. 代码如下：

   ```C
   int binary_search3(int *arr, int n) {
     int head = 0, tail = n, mid;
     while (head < tail) {
       mid = (head + tail) >> 1;
       if (arr[mid] = 1) tail = mid;//这个地方图解写错了！
       else head = mid + 1;
     }
     return tail == n ? -1 : tail;//虚拟尾指针的作用！！！
   }
   ```



## 集大成写法(风骚写法)

1. 思路

   ==就是大体思路不变，但是循环到最后还剩几个元素时改为顺序查找！！==

2. 代码如下

   ```c
   int binart_search(int *arr, int n, int x) {
     int head = 0, tail = n - 1, mid;
     while (head + 3 <= tail) {
       mid = (head + tail) >> 1;
       if (arr[mid] == x) return mid;
       if (arr[mid] < x) head = mid + 1;
       else tail = mid - 1;
     }
     for (int i = head, i <= tail; i++) {
       if (arr[i] == x) return i;
     }
     return -1;
   }
   ```

   

## 二分答案

1. 本质：

   + 二分的是==问题规模==！！

   + 其实本质上也是==试==，只不过由于其单调非递减性，试的速度快了很多！

2. 关键：

   + 上下界的寻找(HZOJ391)

   + ==“是否满足条件”==的判断函数的编写！
     + 当你想不出时，可以曲线救国！比如HZOJ391题(数列分段)！

   ```c++
   //当你想不出“每段和的最大值为x可不可以”时，你可以先假设可以，根据这个条件去求能不能分成m段！
   ```

3. 常用于

   + 求最值

     + HZOJ

       390(原木切割) 393(切绳子)

       389(暴躁的程序猿) 392(丢瓶盖)

       391(数列分段)



# 三分查找

## 综述

我们知道，在一个有序序列里，可以用二分查找进行快速地查找。当然我们也可以在一个单调函数中，用二分查找精确求解其中某一点的值。那如果函数是一个凸形函数或者凹形函数，我们应该如何快速地查找极值点呢？是不是可以借鉴二分查找的方法来求解呢？





1. 我们可以用三分查找来解决凹凸型函数求极值点的问题。

2. #### ![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1gc41yfv8rhj31qu0p8td8.jpg)

![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1gc4224hkyyj31q80psdp9.jpg)

![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1gc423njgjqj31qa0aewh6.jpg)

3. ASL:

   ![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gc424p5gzuj31q807odi6.jpg)



# 分块查找

即Blocking Search， 查找效率介于顺序查找和二分之间

1. 基本思想：

   将一个线性表分成若干子表，在查找时，先确定目标元素所在的子表再在该子表中去查找它。

2. 分块查找也被叫做索引顺序查找，在分块查找中，我么你需要建立一个索引表。索引表中包含两类信息：关键字和指针。

   其中，关键字指的是每个子表中最大的关键字，指针则表示该子表中第一个元素在整个表中的下标。

3. 可能同学们已经在猜想了，我们该如何去确定待查找的记录存在于哪一个子表呢？

   事实上，分块查找要求整个线性表是分块有序的。

   分块有序指的是当将一个线性表分成若干个子表后，第i个子表中所有元素的关键字都小于第i+1块子表的所有元素的关键字。

   我们可以理解成第i个子表中最大的关键字小于第i+1个子表中最小的关键字 。

   索引表中的每一项是按照关键字进行排序，因此，我们可以很容易在索引表中使用折半查找的方法找到目标元素所在的子表。

   而在每一个子表中，元素的排列是任意的，我们只能通过顺序查找的方法在子表中完成最终的查找工作。

4. ASL:

   ![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gc4338lklhj31ho0u010y.jpg)

5. 优缺点
   + 优点在于，鱿鱼子表中的元素是随意排序的，我们只要找到对应的块就能直接进行插入和删除操作，而不用大量移动其他的元素，因此它适用于线性表需要频繁的动态变化的情况。
   + 缺点在于它需要一定的内存空间来存放索引表并且要求对索引表进行排序。

# Hashtable

## 综述

1. 哈希表又叫散列表，关键值通过哈希函数映射到数组上，查找时通过关键值直接访问数组。
2. 哈希函数指的是关键值和存储位置建立的对应关系， 查找时只要根据这个关系就能找到目标位置。一般我们只要通过一次查找就能找到目标位置，但有些关键字需要多次比较和查找才能找到，这是为什么呢？因为哈希表里，可能存在关键字不同但是哈希地址相同的情况，也就是产生了冲突。一般情况下，冲突是不可避免的，因为关键字集合往往比哈希地址集合大很多。

![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gc244gchvcj319k0fadnt.jpg)

3. 要提高哈希表的查找效率，关键在于合理地构造哈希函数和优秀的解决冲突的方法。

## 哈希函数

1. 哈希函数的优劣直接影响到哈希表查找的效率，优秀的哈希函数可以减少冲突的发生，哈希表里的元素可以是不同类型的，也可以是不同规律的，所以不同情况下哈希函数的设计也是不同的。

2. 常见构造方法：

   + 直接寻址法

     即取关键字的值或者关键字的某个函数变换值，线性地映射到存储地址上。如果关键字的数量和跨度不是很大，直接寻址法是最简单有效的构造方法了，并且还可以避免冲突。但是如果关键字的数量和跨度很大的话，这种方法就用不了了，例如有n个关键字，值最小的为0，最大的为pow(10, 10)，这种情况下就不能用直接寻址法了，因为没有足够的空间可以用来存储。

   + 除留余数法

     我们将关键字对整数p取的余数直接作为存储地址，整数p一般取小于等于哈希表长度size的最大质数，如果关键字不是整数，比如是一个字符串，可以先将其做个转换，然后再对p取余。选择优秀的p可以减少冲突的发生。

   + 分析数字法、随机数法……

3. 设计哈希函数没有统一的方法，同一个哈希函数不一定能使用所有问题，其产生的影响也是不一样的。但哈希函数的设计又是至关重要的，那么我们应该如何设计呢？一般来说，设计哈希函数时要达到两个要求：

   + 计算简单

     计算复杂的哈希函数会增加查询的时间。

   + 关键字尽可能地均分到存储地址上，这样可以减少冲突。



## 处理冲突的办法

1. 首先我们了解到可以通过构造优秀的哈希函数来减少冲突，但是一般情况下冲突是不可避免的，而解决冲突的方法也会影响哈希表的查找效率，因此选择一个优秀的方法来处理冲突显得尤为重要。

2. 开放地址法

   如果发生冲突，那么就使用某种策略寻找下一存储地址，知道找到一个不冲突的地址或者找到关键字，否则一直按这种策略继续寻找。如果冲突次数达到了上限则终止程序，表示关键字不存在哈希表里。

   一般常见的策略有这么几种：

   + 线性探测法：如果当前的冲突位置为d，那么接下来几个探测地址为d+1, d+2,d+3等，也就是从冲突地址往后面一个一个探测。
   + 线性补偿探测法：它形成的探测地址为d+m,d+2m, d+3m等，与线性探测法不同，这里的查找单位不是1，而是m，为了能遍历到哈希表里所有位置，我们设置m和表长size互质。
   + 随机探测法，这种方法和前两种方法类似，这里的查找单位不是一个固定值，而是一个随机序列。
   + 二次探测法，它形成的探测地址为d+1^2, d-1^2, d+2^2, d-2^2等，这种方法在冲突位置左右跳跃着寻找探测地址。

   开放地址法计算简单快捷，处理起来方便，但是也存在不少缺点。

   线性探测法容易形成“堆聚”的情况，即很多记录就连在一块，而且一旦形成“堆聚”，记录会越聚越多。

   另外，开放地址法都有一个缺点，删除操作显得十分复杂，我们不能直接删除关键字所在的记录，否则在查找删除位置后面的元素时，可能会出现找不到的情况，因为删除位置上已经成了空地址，查找到这里时会终止查找。

3. 链地址法

   该方法将所有哈希地址相同的结点链成一个单链表，单链表的头结点存在哈希数组里。链地址法常出现在经常插入和删除的情况下。

   相比开放地址法，链地址法有以下优点：

   + 不会出现“堆聚”现象，哈希地址不同的关键字不会发生冲突。

   + 不需要重建哈希表。

     在开放地址法中，如果哈希表里存满关键字了就需要扩充哈希表然后重建哈希表，而在链地址法里，因为结点都是动态申请的，所以不会出现哈希表里存满关键字的情况。

   + 关键字删除更方便，只需要找到指定结点的前驱，删除该结点即可。

4. 开放地址法和链地址法各有千秋，适用于不同的情况

   + 关键字规模少的时候，开放地址法比链地址法更省空间，因为用链地址法可能会存在哈希数组出现大量空地址的情况。
   + 关键字规模大的时候，链地址法就比开放地址法更省空间，链表产生的指针域可以忽略不计，关键字多，哈希数组里的空地址就少了。

5. 其他方法：再哈希法、建立公共溢出区



## 代码演示

处理冲突的方法以链地址法为例！！

![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gc7wnt779yj30ei0g1gm7.jpg)



### 结构定义

```c
typedef struct Node {
  char *str;
  struct Node *next;
} Node;

typedef struct HashTable {
  Node **data;
  int size;
} HashTable;
```

### 结构操作

#### 初始化与回收

```C
Node *init_Node(char *str, Node *head) {
  Node *p = (Node *)malloc(sizeof(Node));
  p->str = strdup(str);//将原来str字符串拷贝过来
  p->next = head;
  return p;
}

HashTable *init_HashTable(int n) {
  HashTable *h = (HashTable *)malloc(sizeof(HashTable));
  h->size = n << 1;//开两倍的空间
  h->data = (Node **)calloc(h->size, sizeof(Node *));
  return h;
}

void clear_Node(Node *node) {
  if (!node) return ;
  Node *p = node, *q;
  while (p) {
    q = p->next;
    free(p->str);
    free(p);
    p = q;
  }
  //free(q);
  return ;
}

void clear_HashTable(HashTable *h) {
  if (!h) return ;
  for (int i = 0; i < h->size; i++) {
    clear_Node(h->data[i]);
  }
  free(h->data);
  free(h);
}
```



#### 哈希函数

```C
int BKDRHash(char *str) {
  int seed = 31, hash = 0;
  for (int i = 0; str[i]; i++) hash = (hash * seed + str[i]);
  return hash & 0x7fffffff;
}
```

#### 插入表中

```C
int insert(HashTable *h, char *str) {
  int hash = BKDRHash(str);
  int ind = hash % h->size;//防止出界！！！
  h->data[ind] = init_Node(str, h->data[ind]);
  return 1;
}
```

#### 查找

```C
int search(HashTable *h, char *str) {
  int hash = BKDRHash(str);
  int ind = hash % h->size;
  Node *p = h->data[ind];
  while (p && strcmp(p->str, str)) {
    p = p->next;
  }
  return p != NULL;
}
```

