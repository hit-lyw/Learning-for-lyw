# 典型例题

## 蒜头君的魔法机

1. 题面：就是给定一个长度为n的数字序列(数字是1~n)，让判断是不是经过栈出来的。

   比如n = 5, 2 1 5 4 3则yes，而5 1 4 2 3则no

2. 解题的心路历程(耗时2h)：

   1. 一开始是完全没思路的。。比较痛苦，但是还是得继续深入思考一段时间，不能看答案，否则思维能力得不到提升。

   2. 后来由一组合法的序列和一组非法的序列(上面的例子)各自的特征总结出了1st思路

      就是利用stack,先让1进栈，然后依次判断序列中的每个数，如果这个数

      + x == top(s),那么就让这个数出栈。

      + x > top(s), (比如例子1中的2)那么就让小于等于这个数但大于栈顶元素的数字依次进栈，最后pop(s)。

      + x < top(s),肯定是非法的，return false;

      + 代码如下

      + ```c
        for (int i = 0; i < n; i++) {
                int x;
                scanf("%d", &x);
                if (x == top(s)) {
                    pop(s);
                } else if (x > top(s)) {
                     	for (int j = top(s) + 1; j <= x; j++) push(s, j);
                    	pop(s);
                    }
                } else {
                    printf("NO\n");
                    return 0;
                }
            }
        ```

        

   3. 提交之后发现了bug，遇到的一个bug是3 2 4 1 5, 原来是因为按上面1st版的思路进行到4时，会进入case2， 但是此时3已经出栈了，不能再入栈了,所以先前的思路是有问题的，然后我就给出了2nd版思路，就是在1st版思路的基础上，加一个flag数组来记录每个数字是否已经入栈后出栈的，还有需要改动的就是在case2中，分两种情况，一是前一个数字还没入栈的，继续原来的思路，二是前一个数字已经出栈，那这个数字肯定也合法，直接算成已经入栈并且出栈的。

      代码如下

      ```C
      for (int i = 0; i < n; i++) {
              int x;
              scanf("%d", &x);
              if (x == top(s)) {
                pop(s);
                flag[x] = 1;//表明已经出栈
              } else if (x > top(s)) {
                  if (!flag[x - 1]) {
                  	for (int j = top(s) + 1; j <= x; j++) {
                      	push(s, j);
                     }
                  	pop(s);
                  	flag[x] = 1;
                  } else {
                      flag[x] = 1;
                      continue;
                  }
              } else {
                  printf("NO\n");
                  return 0;
              }
          }
      ```

   4. 提交之后发现遇到了2nd个bug即3 4 2 5 7 8 6 10 9 1，问题出现在当到了数字7时，2345已经入栈后出栈了，但前一个数字6还没入栈，既不能直接continue(见上面代码中唯一一个continue)， 也不能让前面的数字再入栈出栈，所以，我2nd版思路对1st的bug的改进还不够全面，也就是对全集划分还不够完备。

      经过思考后，我给出了3rd的解决方案，就是如果进入到(!flag[x - 1])那段代码里，不能从j = top(s)+1开始直到x一直入栈，而是要从x - 1开始往前找到第一个没有入栈的数字，从那个数字开始一直到x依次入栈，最后弹出x；

      那个if后的代码如下：

      ```C
                  if (!flag[x - 1]) {
                      int ind;
                      for (ind = x - 1; flag[ind] == 0; ind--)
          
                      for (int j = ind + 1; j <= x; j++) push(s, j);
                      //不能像下面这么干！！！
                  	/*for (int j = top(s) + 1; j <= x; j++) {
                      	push(s, j);
                      }*/
                  	pop(s);
                  	flag[x] = 1;
      ```

   5. 提交之后发现3rd个bug，就是一开始我就让1入栈了，但是这样的话按照上一版代码，例子1中第一个数2就会再次让1入栈，这样就有2个1了，就错了。

      解决方案：不让1一开始就入栈即可。

   6. 提交之后发现4th个bug，就是很奇怪的bug，最后我在每个地方都加了个printf后发现，原来是上一版代码中的第一个for循环后面没加个空语句！！！这样程序就被误认为是个双层循环！！

      终极代码：

      ```C
      #define MAX_N 100
      int flag[MAX_N + 5] = {1};
      
      int main() {
          Stack *s = init_Stack(100);
          //push(s, 1);
          int n;
          scanf("%d", &n);
         	for (int i = 0; i < n; i++) {
              int x;
              scanf("%d", &x);
              if (x == top(s)) {
                  pop(s);
                  flag[x] = 1;
                  //printf("x = %d == top(s) flag[%d] = 1\n", x, x);
                  //output(s);
              } else if (x > top(s)) {
                  if (!flag[x - 1]) {
                      int ind;
                      for (ind = x - 1; flag[ind] == 0; ind--)
                      {}
                      for (int j = ind + 1; j <= x; j++) push(s, j);
                      //不能像下面这么干！！！
                  	/*for (int j = top(s) + 1; j <= x; j++) {
                      	push(s, j);
                      }*/
                  	pop(s);
                  	flag[x] = 1;
                     // printf("x = %d ind = %d flag[%d] = 1\n", x, ind, x);
                      //output(s);
                  } else {
                      flag[x] = 1;
                      //printf("x = %d flag[%d] = 1, so flag[%d] = 1\n", x, x - 1, x);
                      //output(s);
                      continue;
                  }
              } else {
                  //printf("x = %d top(s) = %d\n", x, top(s));
                  printf("NO\n");
                  return 0;
              }
          }
          printf("YES\n");
          return 0;
      }
      ```

      

# 应用

## 单调栈

1. 实例：

   现在有很多人在排队买可乐，每个人手里都拿着号，越靠前的人手里的号越小，但是号不一定是连续的。有一个人拿了号后并没有去排队而是跑去约会了。等他回来后，发现队伍已经排得很长了，他不能直接插入到队伍里，不然人家以为他是来插队的。于是他跑到队伍最后，挨个询问排队人手里的号码是多少，他认为号比他大的人都是“插队”的，于是施魔法把这些人变消失，直到找到号比他小的为止。

   在上面的场景里，同学们排的队伍就像是单调栈，因为同学们手里拿的号是单调递增的。一个同学找到自己的位置并加入队伍中的这个过程就是元素加入单调栈的过程。如果新加入的元素加到栈顶后，栈里的元素就不再是单调递增了，那么我们就删除加入前的栈顶元素，就像施魔法把“插队”的人变消失一样。只有当新元素加入后，栈依然是单调递增的，我们才把元素加进栈里。

2. 单调栈的维护是O(n)的时间复杂度，因为所有元素只会进出栈各一次。

3. 应用：解决临近最值问题！

   ### 经典例题

   #### 一

   1. 题面：给定一个包含若干整数的数组，对于其中每个元素，计算左边离它最近的比它小的元素。
   2. 解法：我们从第一个元素开始依次加入到单调栈里，并且加入后更新单调栈。那么单调栈有这样的性质：对于从栈顶到栈底单调递减的栈，如果此时栈顶元素为b，加入新元素a后进行更新时，如果a>b，说明如果从a在数组中的位置开始往左边遍历，则b一定是第一个比a小的元素；如果a小于b，那么对于a右侧的元素来说，b就失去了比较的意义，因此将b从栈中弹出，并继续让a和栈底元素判断。

   