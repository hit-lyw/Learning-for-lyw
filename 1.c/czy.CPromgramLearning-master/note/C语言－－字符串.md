# C语言－－字符串

1. 字符串相关操作:

   头文件: string.h
   
   | 函数                    | 说明                                                         |
   | ----------------------- | ------------------------------------------------------------ |
   | strlen(str)             | 计算字符串长度，以'\0'作为结束符                             |
   | strcmp(str1, str2);     | 字符串比较(以'\0'作为结束符)(but万一str2最后的结束符不小心没了就不安全了) |
   | strcpy(dest, strc);     | 字符串拷贝(同上)                                             |
   | strncmp(str1, str2, n); | ==安全==的字符串比较                                         |
   | strncpy(str1, str2, n); | ==安全==的字符串拷贝                                         |
   | memcpy(str1, str2, n);  | 内存拷贝(以下三个函数都是以==字节==为操作单位)(与strncmp不同的是这个一定会拷贝n个字节，而strncmp不一定会拷贝到n个字节) |
   | memcmp(str1, str2, n);  | 内存比较                                                     |
   | memset(str1, c, n);     | 内存设置(==str为首地址，将后面连续n个字节设置为c==)          |
   
   一些更灵活的操作：
   
   头文件：stdio.h
   
   | 函数                        | 说明                                                         |
   | --------------------------- | ------------------------------------------------------------ |
   | sscanf(str1, format, ...);  | 从字符串str1读入内容（==将字符串数据转换成任意类型数据==)    |
   | sprintf(str1, format, ...); | 将内容输出到字符串str1中(==将任意类型的数据转化成字符数据==) |
   
   
   
   
   
   PS:1. 
   
   ```c
   int arr[100];
   memset(arr, 0, sizeof(arr));                  //由于是按字节一个字节一个字节赋值，所以这就相当于全部赋值为０
   memset(arr, 1, sizeof(arr));                       //由于是按字节一个字节一个字节赋值，而int有四个字节，所以绝不会每个元素变成１
   memset(arr, -1, sizeof(arr));　　　　//由于是按字节一个字节一个字节赋值，考虑到-1的二进制表示，所以每个元素会变成-1
   ```

2. 在计算机中，正数以原码表示（因为正数的补码还是原码），而负数以补码表示，即==正数按位取反再加一==, 即(-x)和(~x + 1)是完全一样的。

3. 计算机中不管几位的二进制数，负数的最小值都是"1000000..."(==都减完了==)，而这个数对应的正数就是它本身（按位取反再加一），正数的最大值对应的极小值是1000...1。

   

